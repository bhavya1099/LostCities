// Test generated by RoostGPT for test java-unit-test-bhavya using AI Type Open AI and AI Model gpt-4

package com.lostcities.lostcities.domain.game;

import com.lostcities.lostcities.domain.game.card.Card;
import com.lostcities.lostcities.domain.game.card.Deck;
import com.lostcities.lostcities.domain.game.exception.EmptyDeckException;
import com.lostcities.lostcities.domain.game.exception.GameNotStartedException;
import com.lostcities.lostcities.domain.game.exception.IllegalMoveException;
import com.lostcities.lostcities.domain.game.exception.NotPlayersTurnException;
import com.lostcities.lostcities.domain.user.User;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Arrays;

import static org.junit.Assert.assertThrows;
import static org.mockito.Mockito.when;

public class Game_validateMove_5deaf616c4_Test {

    @Mock
    private Move move;

    @Mock
    private Move previousMove;

    @Mock
    private Player player;

    @Mock
    private Deck deck;

    private Game game;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        game = new Game(Arrays.asList(player, player), deck);
    }

    @Test
    public void testValidateMove_InvalidPlayer() {
        when(move.getPlayer()).thenReturn(null);
        assertThrows(IllegalStateException.class, () -> game.validateMove(move, previousMove));
    }

    @Test
    public void testValidateMove_EmptyDeck() {
        when(move.getPlayer()).thenReturn(player);
        when(deck.isEmpty()).thenReturn(true);
        assertThrows(EmptyDeckException.class, () -> game.validateMove(move, previousMove));
    }

    @Test
    public void testValidateMove_GameNotStarted() {
        when(move.getPlayer()).thenReturn(player);
        when(deck.isEmpty()).thenReturn(false);
        when(move.allowedBeforeGameStarts()).thenReturn(false);
        game.setStatus(Status.NotStarted);
        assertThrows(GameNotStartedException.class, () -> game.validateMove(move, previousMove));
    }

    @Test
    public void testValidateMove_NotPlayersTurn() {
        when(move.getPlayer()).thenReturn(player);
        when(deck.isEmpty()).thenReturn(false);
        when(move.allowedBeforeGameStarts()).thenReturn(true);
        when(move.doesTurnMatter()).thenReturn(true);
        game.setStatus(Status.Started);
        game.setCurrentTurnPlayer(null);
        assertThrows(NotPlayersTurnException.class, () -> game.validateMove(move, previousMove));
    }

    @Test
    public void testValidateMove_IllegalMove() {
        when(move.getPlayer()).thenReturn(player);
        when(deck.isEmpty()).thenReturn(false);
        when(move.allowedBeforeGameStarts()).thenReturn(true);
        when(move.doesTurnMatter()).thenReturn(false);
        when(move.canPlayAfter(previousMove)).thenReturn(false);
        game.setStatus(Status.Started);
        game.setCurrentTurnPlayer(player);
        assertThrows(IllegalMoveException.class, () -> game.validateMove(move, previousMove));
    }
}
