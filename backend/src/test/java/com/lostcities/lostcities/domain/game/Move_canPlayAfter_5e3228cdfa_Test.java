// Test generated by RoostGPT for test java-unit-test-bhavya using AI Type Open AI and AI Model gpt-4

package com.lostcities.lostcities.domain.game;

import com.lostcities.lostcities.domain.game.exception.EmptyDeckException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.when;

public class Move_canPlayAfter_5e3228cdfa_Test {

    @Mock
    private Move previousMove;

    private Move currentMove;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.initMocks(this);
        currentMove = new Move();
    }

    @Test
    public void testCanPlayAfter_AllowedBeforeGameStarts() {
        when(currentMove.allowedBeforeGameStarts()).thenReturn(true);
        assertTrue(currentMove.canPlayAfter(previousMove));
    }

    @Test
    public void testCanPlayAfter_PreviousMoveIsNull() {
        assertFalse(currentMove.canPlayAfter(null));
    }

    @Test
    public void testCanPlayAfter_IsDrawingCardJustDiscarded() {
        when(currentMove.isDrawingCardJustDiscarded(previousMove)).thenReturn(true);
        assertFalse(currentMove.canPlayAfter(previousMove));
    }

    @Test
    public void testCanPlayAfter_FirstMoveOfTurn() {
        when(previousMove.doesEndTurn()).thenReturn(true);
        when(currentMove.getType().stage.isFirstStage()).thenReturn(true);
        assertTrue(currentMove.canPlayAfter(previousMove));
    }

    @Test
    public void testCanPlayAfter_MoveIsOneOrderAbovePrevious() {
        when(previousMove.getType().stage.order).thenReturn(1);
        when(currentMove.getType().stage.order).thenReturn(2);
        assertTrue(currentMove.canPlayAfter(previousMove));
    }

    @Test
    public void testCanPlayAfter_MoveIsNotOneOrderAbovePrevious() {
        when(previousMove.getType().stage.order).thenReturn(1);
        when(currentMove.getType().stage.order).thenReturn(3);
        assertFalse(currentMove.canPlayAfter(previousMove));
    }
}
